- @format_date = '%Y-%m-%d'
- @format_time = '%H:%M:%S'

.modal.fade#eventModal
  .modal-dialog
    .modal-content
      / = form_for [@unit, @event_view.event] do |f|
      - url = @event_view.new_record? ? unit_events_path(@unit) : event_path(@event_view.event)
      - method = @event_view.new_record? ? 'post' : 'patch'
      = form_with model: @event_view, scope: 'event', url: url, method: method do |f|
        .modal-header
          - if @event.new_record?
            h5.modal-title = t(:event_add)
          - else
            h5.modal-title = t(:event_update)
          button.btn-close(type="button" data-bs-dismiss="modal")

        .modal-body
          / EVENT CATEGORY
          .mb-3
            = f.label :category, class: 'col-form-label'
            = f.select :event_category_id,
              @event.unit.event_categories.collect { |c| [ c.name, c.id ] },
              { prompt: t('event_category_prompt') },
              { class: 'form-select' }

          / TITLE
          .mb-3
            = f.label :title
            = f.text_field :title, { class: 'form-control', autocomplete: 'off', style: 'text-transform: capitalize' }

          // from date
          .mb-3
            .form-text = t('events.form.timezone_prompt', timezone_name: @current_unit.settings(:locale).time_zone)

          .mb-3
            .row.mb-3
              .col-sm-2.pt-2
                = f.label :from
              .col-sm-5
                = f.date_field :starts_at_date, class: 'form-control'

              .col-sm-5
                = f.time_field :starts_at_time, class: 'form-control', step: '900', value: @event.starts_at.localtime.strftime("#{ @format_time }")

          // to date
          .mb-3
            .row.mb-3
              .col-sm-2.pt-2
                = f.label :to
              .col-sm-5
                 = f.date_field :ends_at_date, class: 'form-control'
              .col-sm-5
                 = f.time_field :ends_at_time, class: 'form-control', step: '900', value: @event.ends_at.localtime.strftime("#{ @format_time }")

          // repeats
          .row.mb-3(style="height:3rem;")
            .col-md-6
              .form-check.form-check-inline(style="padding-top:6px;")
                = check_box_tag 'event_repeats', nil, false, class: 'form-check-input', data: { 'bs-toggle' => 'collapse', 'bs-target' => '#repeat-fields'}, onclick: 'updateRepeatLabel(this);'
                = f.label :repeats, class: 'form-check-label', id: 'repeat-label'

            // repeat end date
            .col-md-5
              .collapse#repeat-fields.input-group
                = f.date_field :repeats_until, value: (@event.starts_at + 6.months).strftime("#{ @format_date }"), class: 'form-control'

          // location
          .mb-3
            = f.label :location
            = f.text_field :location, { class: 'form-control', autocomplete: 'off', style: 'text-transform: capitalize' }

          .mb-3
            = f.label :address
            = f.text_field :address, { class: 'form-control', autocomplete: 'off', style: 'text-transform: capitalize' }

          .mb-3
            = f.label :departs_from
            = f.text_field :departs_from, { class: 'form-control', autocomplete: 'off', style: 'text-transform: capitalize' }

          // RSVP
          .form-check.mb-3
            = f.check_box :requires_rsvp, class: 'form-check-input', data: { 'bs-toggle' => 'collapse', 'bs-target' => '#rsvp-fields'}
            = f.label :requires_rsvp, class: 'form-check-label'

          // RSVP fields
          .mb-3.collapse#rsvp-fields(style="padding-left: 24px;")
            .mb-3
              label
                | RSVP opens&nbsp;
                a(href="#") immediately
                | &nbsp;and closes&nbsp;
                a(href="#") 2 weeks before start

            .form-check.mb-3
              = check_box_tag 'rsvp_notify', '', false, class: 'form-check-input'
              = label_tag :rvsp_notify, t('helpers.label.event.rsvp_notify'), class: 'form-check-label'

          // series edit
          - if @event.series?
            .mb-3
              = f.label :update_scope, class: 'form-check-label', style: 'margin-right: 1rem;'

              .form-check.form-check-inline
                = radio_button_tag :update_scope, :single, true, class: 'form-check-input'
                = label_tag :update_single, t('helpers.label.event.update_scope_single'), class: 'form-check-label'

              .form-check.form-check-inline
                = radio_button_tag :update_scope, :series, false, class: 'form-check-input'
                = label_tag :update_series, t('helpers.label.event.update_scope_series'), class: 'form-check-label'

        // form buttons
        .modal-footer
          - if @event.new_record?
            = f.submit t('helpers.label.event.accept_button'), class: 'btn btn-primary', id: 'event_submit'
            button.btn.btn-secondary(type="button" data-bs-dismiss="modal") = t('helpers.label.event.cancel_button')

          - else # updating an existing record
            = f.submit t('helpers.label.event.update_button'), class: 'btn btn-primary', id: 'event_submit', style: 'margin-right: 10px;'
            button.btn.btn-secondary(type="button" data-bs-dismiss="modal") = t('helpers.label.event.cancel_update')

javascript:

  var isTitleDirty = false;

  setupDialog();

  function setupDialog() {
    setupCategoryDropdownHandler();
    setupDateHandlers();
    validateDialog();
  }

  function setupCategoryDropdownHandler() {
    document.getElementById('event_event_category_id').addEventListener('change', function() {
      if (isTitleDirty) { return; }

      const catId = this.value;
      const catName = this.options[this.selectedIndex].text;
      const eventTitle = document.getElementById('event_title');
      eventTitle.value = catName;

      validateDialog();
    });

    document.getElementById('event_title').addEventListener('change', function() {
      isTitleDirty = true;
    });
  }

  // TODO: DRY this out
  function setupDateHandlers() {
    // if start date is later than end date, then update end date to match
    document.getElementById('starts_at_d').addEventListener('change', function() {
      const startsAtDateField = document.getElementById('starts_at_d');
      const endsAtDateField = document.getElementById('ends_at_d');
      const startsAtDate = Date.parse(startsAtDateField.value);
      const endsAtDate = Date.parse(endsAtDateField.value);

      if (startsAtDate > endsAtDate) {
        endsAtDateField.value = startsAtDateField.value;
      }
    });

    document.getElementById('event_repeats_until').addEventListener('focus', function() {
      this.dataset.originalValue = this.value;
    });

    document.getElementById('event_repeats_until').addEventListener('change', function() {
      const startsAtDateField = document.getElementById('starts_at_d');
      const repeatsUntilDateField = document.getElementById('event_repeats_until');
      const startsAtDate = Date.parse(startsAtDateField.value);
      const repeatsUntilDate = Date.parse(repeatsUntilDateField.value);

      console.log('checking repeat date');

      if (repeatsUntilDate < startsAtDate) {
        console.log('repeat date cannot be before start date');
        this.value = this.dataset.originalValue;
        flagValidationError(this);
      }
    });

    document.getElementById('ends_at_d').addEventListener('focus', function() {
      this.dataset.originalValue = this.value;
    });

    // if start date is set earlier than start date, mark as error
    document.getElementById('ends_at_d').addEventListener('change', function() {
      const startsAtDateField = document.getElementById('starts_at_d');
      const endsAtDateField = document.getElementById('ends_at_d');
      const startsAtDate = Date.parse(startsAtDateField.value);
      const endsAtDate = Date.parse(endsAtDateField.value);

      if (endsAtDate < startsAtDate) {
        this.value = this.dataset.originalValue;
        flagValidationError(this);
      }
    });
  }

  function flagValidationError(elem) {
    elem.classList.add('error');
    setTimeout(function(elem) {
      document.getElementById('ends_at_d').classList.remove('error');
    }, 2000);
  }

  // enable / disable Accept button depending on validation status
  function validateDialog() {
    var valid = false;
    const categoryId = document.getElementById('event_event_category_id').value;
    if(!!categoryId) {
      valid = true;
    }

    const commitButton = document.getElementById('event_submit');
    commitButton.disabled = !valid;
  }

  // when the Repeat box is checked, the caption should update
  function updateRepeatLabel(elem) {
    const label = document.getElementById('repeat-label');
    const checkBox = document.getElementById('event_repeats');
    const caption = checkBox.checked ? 'Repeats weekly until' : 'Repeats weekly';
    label.innerText = caption;
  }

  function setupGeocoding() {
    const baseClient = mbxClient({ accessToken: '#{ ENV['MAPBOX_TOKEN'] }' });
    const geocodingClient = mbxGeocoding(baseClient);
  }

  // setupGeocoding();

scss:
  #calendar {
    background: #eee;
    position: absolute;
    display: 'block';
    left: 0;
    top: 0;
    font-size: 80%;
  }

  #calendar table {
    display: block;
    margin: 15px;
  }

  #calendar {
    .sp-cal-wrapper {
      display: inline-block;
      width: 50%;
    }

    .sp-cal-wrapper:first-child {
      padding-right: 12px;
    }

    .sp-cal-wrapper:last-child {
      padding-left: 12px;
    }

    th, td {
      text-align: center;
      padding: 0;
    }

    td {
      pointer: hand;
    }
  }

  .sp-cal-day {
    a {
      display: inline-block;
      padding: 4px;
      border-radius: 50%;
      pointer: default;
      width: 100%;
      text-decoration: none;
      color: #333;

      &:hover {
        background-color: #ddd;
      }
    }
  }
